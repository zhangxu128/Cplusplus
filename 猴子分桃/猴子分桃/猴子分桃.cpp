//老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富――一大堆桃子。老猴子决定把这些桃子分给小猴子。
//第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
//第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
//后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
//这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。



//
//设原来有x个桃子，假设供5个小猴子，因为第一只猴子拿一个给老猴子，正好可以分成5堆，
//所以我们借给猴子4个桃子，那么正好可以分成5堆，第一个猴子就拿了其中一堆（包括老猴子的一个），
//但是，它并没有多得桃子，就是（x + 4）× （1 / 5) = (x - 1) * 1 / 5
//第1个小猴子拿走一份，这一份包括自己的那部分和老猴子的一个。那么剩余桃子是(x + 4)*(4 / 5)。
//这剩余的桃子中多了4个。由于每次分因为要给老猴子一个，所以算上多出来的4个，每次均能5等分。
//那么分5次后剩余桃子为(x + 4)*(4 / 5) ^ 5，显然保证x最小，
//且剩余为整数那么x + 4 = 5 ^ 5 = > x = 5 ^ 5 - 4 这样得到总的桃子数。
//而老猴子的桃子为每次小猴子分给老猴子的一个桃子加上剩余没分完的桃子，
//并减去最初多添加进来的4个桃子。 为 5 + (x + 4)*(4 / 5) ^ 5 - 4 。 这里5换成n即得到最终的公式。


#include<stdio.h>
#include<math.h>

int main()
{
	unsigned long n, a, b;
	while (scanf("%lu", &n)) {
		if (n == 0) break;

		a = (unsigned long)pow(5, (double)n);
		b = (unsigned long)pow(4, (double)n);

		printf("%lu %lu\n", a - 4, b - 4 + n);
	}
	return 0;
}